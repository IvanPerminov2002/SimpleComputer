#include <stdio.h>

#difine N 100
//оперативная память массив целых чисел 100 элементов
int sc_memoryInit(){

	int memory[N] = {0}
}
//задает значение ячейки указанной памяти как value, если за границей памяти то флаг выход за 
////границу, то работа функции прекращается с ошибкой
int sc_memorySet(int address, int value){
	bool flag = true;
	if (value > 99) || (value < 0) flag = false;

}
//возваращает значение указанной ячейки памяти в value, если адрес выходит за границы, 
// то устанавливается флаг "выход за границу памяти", заначение переменной валуе не изменяется
int sc_memoryGet(int address, int *value){

}

//сохраняет содержимое памяти в бинарный файл (write, fwrite)
int sc_memorySave(char* filename){

}

//загружает из указанного файла содержимое оперативной памяти
int sc_memoryLoad(char* filename){

}

//инициализирует регистр флагов нулевым значением
int sc_regInit(void){

}

//устанавливает значение указанного регистра флагов. для номеров регистров флагов должны 
//использоваться маски, задаваемые макросами №дефайн
//если указан недопустимый номер регистра функция завершается с ошибкой
int sc_regSet(int register, int value){

}

//возвращает значение указанного флага

int sc_regGet(int register, int * value){

}

//кодирует команду с указанным номером и операндом и помещает результат в валуе. Если указаны
// неправельные значения, то функция завершается с ошибкой, валуе не изменяется
int sc_commandEncode(int command, int operand, int *value){

}

//декодирует значение как команду симплкомпьютер . если декодирование невозможено, устанавливается
// флаг "ошибочная команда" и функция завершается с ошибкой
int sc_commandDecode(int value, int * comand, int *operand){

}
